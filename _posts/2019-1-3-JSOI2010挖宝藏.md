---
layout: post
title: 2019-1-3 [JSOI2010]挖宝藏

date: 2019-1-3
categories: blog
tags: [JSOI,2010]
description: BZOJ5023
---

---------------------
![1.png](https://i.loli.net/2019/01/03/5c2e0a01dc38d.png)
![2.png](https://i.loli.net/2019/01/03/5c2e0a12dc7de.png)


---------------------------------------------------------------------------------------------------------

# Answer

首先这个题极其偏僻然后网上找不到题解(甚至找不到题目)

~~不知道为什么江苏省选题会没有题解~~

然后在BZOJ上只有8个人通过。。。非常少

然后我看了下觉得可做然后就尝试写了

~~实际上我想了近2星期~~

这个1000的范围实在是容易让人想偏到建图上面去

实际上还是应该遵循dp的初始想法，然后是个n^2DP

实际上我觉得这个题关键在于合理安排DP顺序。不难发现每个阶段总是像山峦一样有很多个凸起，然后你想记录这个状态是非常困难的

然后再加一个新的进来，就很难搞清楚这个东西的价值或者代价是多少

![3.png](https://i.loli.net/2019/01/03/5c2e0c3a171bf.png)

如图，红色是新加进来的，然后蓝色是已经挖了的就很难计算非重合部分面积

然后和xyh口胡的时候他说了一个点子非常有启发。

就是在描述一个宝藏时，也可以把他映射到y=-1这个直线上的两个点

好吧用处也不是很大需要理解下

然后我就想如果可以合理安排DP顺序使得每次转移不会出现刚刚那个恶心的情况，而都是这样：

![4.png](https://i.loli.net/2019/01/03/5c2e0cddaa49d.png)

该多好算

然后就over了这个题。~~说起来好简单，主要时间浪费在排除其他做法了可能~~

首先进行排序，保证第i个宝藏不可能完全包含第i - 1个宝藏。

相当于也是如果i包含j就连一条i->j的有向边，然后逆拓扑序

然后进行dp,dp[i][j]表示选到第i个时，最后一个选的是j的最优解

然后i可能会被j 包含。此时我们可以选择忽视dp[i][i]。为什么这样做是对的呢？

因为以 dp[i][j]转移下去一定比dp[i][i]更优

理解下吧，具体看代码，写的很清楚

``` c++
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<queue>
#include<stack>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<cmath>
#include<sstream>
#include<fstream>
using namespace std;
const int MAXN=1011;
const double pi=acos(-1.0);
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef double dbl;
const dbl eps = 1e-10;
const int MOD = 1e9;
const int B = 725;
const int INF = 0x3f3f3f3f;
#define For(a,b,c) for (int (a)=(b);(a)<(c);(a)++)
#define foreach(iter,V) for (__typeof((V.begin()) iter=(V).begin();iter!=(V).end();iter++)
#define mp make_pair
#define fi first
#define se second
#define pb push_back
struct node{
	int x,y,w;
}P[MAXN];
int n;
bool cmp(node a,node b){
	int la,ra;
	la = a.x + a.y + 1;
	ra = a.x - a.y - 1;
	int lb,rb;
	lb = b.x + b.y + 1;
	rb = b.x - b.y - 1;
	return la == lb ? ra > rb : la < lb;
} 
bool inside(node a,node b){
	return a.y >= -a.x + b.x + b.y && a.y >= a.x - b.x + b.y;
}
int area(int l,int r){
	if ((r - l + 1) % 2 == 1)	return (r - l + 2) / 2 * (r - l + 2) / 2;
	return (r - l + 1) / 2 * ((r - l + 1) / 2 + 1);
}
int cross(node a,node b){
	int la,ra;
	la = a.x + a.y + 1;
	ra = a.x - a.y - 1;
	int lb,rb;
	lb = b.x + b.y + 1;
	rb = b.x - b.y - 1;
	if (inside(a,b))	return area(la,ra);
	if (inside(b,a))	return area(lb,rb);
	if (lb <= la && la <= rb)	return area(la,rb);
	if (lb <= ra && ra <= rb)	return area(lb,ra);
	return 0;
}
int dp[1001][1001];
vector<node> ins[1001];
int main(){
	freopen("treasures.in","r",stdin);
	freopen("treasures.out","w",stdout);
	scanf("%d",&n);
	For(i,1,n + 1)	scanf("%d%d%d",&P[i].x,&P[i].y,&P[i].w);
	sort(P + 1,P + n + 1,cmp);
	For(i,1,n + 1)	For(j,1,n + 1)	if (inside(P[j],P[i]))	ins[i].pb(P[j]);
	P[0].x = - INF;
	P[0].y = -1;
	P[0].w = 0;
	For(i,1,n + 1){
		For(j,1,i)	dp[i][j] = dp[i - 1][j];
		dp[i][i] = -INF;
		For(j,0,i)
			if (!inside(P[i],P[j])) {
				int res = dp[i - 1][j];
				int num = 0;
				For(k,0,ins[i].size())	if (!inside(ins[i][k],P[j]))	num += ins[i][k].w;
				int la,ra;
				la = P[i].x + P[i].y + 1;
				ra = P[i].x - P[i].y - 1;
				res += - area(la,ra) + cross(P[i],P[j]) + num;
				if (res > dp[i][i])	dp[i][i] = res;
			}
	}
	int ans = 0;
	For(i,0,n + 1)	if(dp[n][i] > ans) 		ans = dp[n][i];
	printf("%d\n",ans);	
	return 0;
} 
```
