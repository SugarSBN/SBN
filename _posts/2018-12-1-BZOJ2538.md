---
layout: post
title: 2018-12-1 [CTSC2000]公路巡逻

date: 2018-12-1
categories: blog
tags: [CTSC,2000]
description: BZOJ2538
---

---------------------

# Description

在一条没有分岔的高速公路上有n个关口，相邻两个关口之间的距离都是10km。所有车辆在这条高速公路上的最低速度为60km/h，最高速度为120km/h，并且只能在关口处改变速度。
巡逻的方式是在某个时刻Ti从第ni个关口派出一辆巡逻车匀速驶抵第(ni+1)个关口，路上耗费的时间为ti秒。
两辆车相遇是指它们之间发生超车或者两车同时到达某关口（同时出发不算相遇）。
巡逻部门想知道一辆于6点整从第1个关口出发去第n个关口的车（称为目标车）最少会与多少辆巡逻车相遇，请编程计算之。假设所有车辆到达关口的时刻都是整秒。

# input

输入文件第一行为两个用空格隔开的整数，分别为关口数n和巡逻车数m。（1<n<50,1<m<300），接下来的m行每一行为一辆巡逻车的信息（按出发位置递增排序），格式为ni　Ti　ti，三项用空格隔开，分别表示第i辆巡逻车的出发位置、出发时刻和路上耗费的时间，其中ni和ti为整数，Ti形如hhmmss，表示时、分、秒，采用24小时制，不足两位的数用前置0补齐。（1<=ni<n,05:00:00<=Ti<=23:00:00,300<=ti<=600）

# output

输出文件第一行为目标车与巡逻车相遇次数。第二行为目标车与巡逻车相遇次数最少时最早到达第n个关口的时刻（格式同输入中的Ti）。

# Sample input

3 2
1 060000 301
2 060300 600

# Sample output

0
061301

---------------------------------------------------------------------------------------------------------

# Answer

dp[i][j]表示到第i个关口花了j秒最少遇到的车的数量

然后300-600s往回推好了

BZOJ10s时限真是和善    ~~除了BZOJ哪也过不了~~

# Code

``` c++
struct P1{
	int st,t,stt;
	char tim[7];
	char operator [](int x){
		return tim[x];
	}
}xlc[301];
bool cmp(P1 A,P1 B){
	return A.st < B.st; 
}
int n,m;
int f[51][51 * 601];
int T = 6 * 3600;
int main(){
//	freopen("in.txt","r",stdin);
	scanf("%d%d",&n,&m);
	For(i,0,m)	{
		scanf("%d%s%d",&xlc[i].st,xlc[i].tim,&xlc[i].t);
		int res1 = 0;
		res1 = (xlc[i][0] - '0') * 10 + xlc[i][1] - '0' - 6;
		xlc[i].stt = res1 * 3600;
		res1 = (xlc[i][2] - '0') * 10 + xlc[i][3] - '0';
		xlc[i].stt += res1 * 60;
		res1 = (xlc[i][4] - '0') * 10 + xlc[i][5] - '0';
		xlc[i].stt += res1;
	}
	sort(xlc,xlc + m,cmp);
	memset(f,0x3f3f3f3f,sizeof(f));
	f[1][0] = 0;
	For(i,2,n + 1)	{
		int l = -1,r = -1;
		For(j,0,m)	{
			if (xlc[j].st == i - 1 && l == -1)	l = j;
			if (xlc[j].st == i && r == -1)	r = j;
		}
		if (l == -1) l = m;
		if (r == -1) r = m;
		For(j,(i - 1) * 300,(i - 1) * 600 + 1){
			f[i][j] = INF;
			For(k,300,601)	if (k <= j){
				int lstt = j - k;
				int num = 0;
				For(p,l,r)	if (1LL * (lstt - xlc[p].stt) * (j - xlc[p].stt - xlc[p].t) < 0 || (j == xlc[p].stt + xlc[p].t))	num++;
				f[i][j] = min(f[i][j],f[i - 1][lstt] + num);
			}
		}
	}
	int minn = INF,elt;
	For(i,(n - 1) * 300,(n - 1) * 600 + 1)	if (f[n][i] < minn){
		minn = f[n][i];
		elt = i;
	}
	printf("%d\n",minn);
	int hours = elt / 3600;
	elt -= hours * 3600;
	int minu = elt / 60;
	elt -= minu * 60;
	printf("%02d%02d%02d\n",6 + hours,minu,elt);
	return 0;
} 

```