---
layout: post
title: 2019-4-5 三维偏序

date: 2019-4-5
categories: blog
tags: [,]
description: 
---

---------------------

```c++
struct node{
	int x,y,z,cnt;
	int level;
}F1[MAXN],F[MAXN];
bool cmp(node a,node b){
	if (a.x == b.x && a.y == b.y)	return a.z < b.z;
	if (a.x == b.x)	return a.y < b.y;
	return a.x < b.x;
}
bool operator == (node a,node b){
	if (a.x == b.x && a.y == b.y && a.z == b.z)	return 1;
	return 0;
}
int cnt;
int C[MAXN];
int lowbit(int x){return x & -x;}
void add(int pos,int num){
	for (int i = pos;i <= K;i += lowbit(i))	C[i] += num;
}
int getans(int pos){
	int res = 0;
	for (int i = pos;i >= 1;i -= lowbit(i))	res += C[i];
	return res;
}
node tp[MAXN];
void CDQ(int l,int r){
	if (l == r)	return;
	int mid = (l + r) >> 1;
	CDQ(l,mid);CDQ(mid + 1,r);
	int p1 = l,p2 = mid + 1,p3 = l;
	while(p1 <= mid && p2 <= r)	if (F[p1].y < F[p2].y || (F[p1].y == F[p2].y && F[p1].x < F[p2].x))	tp[p3++] = F[p1++];	else tp[p3++] = F[p2++];
	while(p1 <= mid)	tp[p3++] = F[p1++];
	while(p2 <= r)	tp[p3++] = F[p2++];
	For(i,l,r + 1)	F[i] = tp[i];
	For(i,l,r + 1)	if (F[i].x <= mid)		add(F[i].z,F[i].cnt);
	else F[i].level += getans(F[i].z);
	For(i,l,r + 1)	if (F[i].x <= mid)	add(F[i].z,-F[i].cnt);
}
int ans[MAXN];
int main(){
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	scanf("%d%d",&N,&K);
	For(i,1,N + 1){
		scanf("%d%d%d",&F1[i].x,&F1[i].y,&F1[i].z);
		F1[i].level = 0;
		F1[i].cnt = 1;
	}
	sort(F1 + 1,F1 + N + 1,cmp);
	cnt = 0;
	for (int i = 1;i <= N;){
		F[++cnt] = F1[i];
		i++;
		while(i <= N && F1[i] == F1[i - 1])	{
			i++;
			F[cnt].cnt++; 
		} 
	}
	For(i,1,cnt + 1)	F[i].x = i;
	CDQ(1,cnt);
	For(i,1,N + 1)	ans[F[i].level + F[i].cnt - 1] += F[i].cnt;
	For(i,0,N)	printf("%d\n",ans[i]);
	return 0;
} 
```