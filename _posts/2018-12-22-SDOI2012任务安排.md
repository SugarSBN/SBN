---
layout: post
title: 2018-12-22 [SDOI2012]任务安排

date: 2018-12-22
categories: blog
tags: [SDOI,2012]
description: BZOJ2726
---

---------------------

# Description

机器上有N个需要处理的任务，它们构成了一个序列。
这些任务被标号为1到N，因此序列的排列为1,2,3...N。
这N个任务被分成若干批，每批包含相邻的若干任务。
从时刻0开始，这些任务被分批加工，第i个任务单独完成所需的时间是Ti。
在每批任务开始前，机器需要启动时间S，而完成这批任务所需的时间是各个任务需要时间的总和。
注意，同一批任务将在同一时刻完成。每个任务的费用是它的完成时刻乘以一个费用系数Fi。
请确定一个分组方案，使得总费用最小。

# input

第一行两个整数，N,S。
接下来N行每行两个整数，Ti,Fi。
N <= 300000
 

# output

 一个整数，为所求的答案。

# Sample input

5 1

1 3

3 2

4 3

2 3

1 4

# Sample output

153

---------------------------------------------------------------------------------------------------------

# Answer

这个题非常有代表性了于是我自己想了很久

~~然后斜率优化被时间是负数卡了很久，佩服出题人可以把时间出成负数~~

首先把F和T倒过来读，然后求个前缀和

于是就写出了原始dp方程

dp[i]表示把后i个任务合理划分所需最少时间（倒过来了处理）

<a href="https://www.codecogs.com/eqnedit.php?latex=dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]-T[j]&space;\right&space;)\right&space;\}&space;\left&space;(&space;j&space;<&space;i&space;\right&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]-T[j]&space;\right&space;)\right&space;\}&space;\left&space;(&space;j&space;<&space;i&space;\right&space;)" title="dp[i] = min\left \{ dp[j] + F[i] * \left ( s + T[i]-T[j] \right )\right \} \left ( j < i \right )" /></a>

合情合理对吧。。。。然后目测是<a href="https://www.codecogs.com/eqnedit.php?latex=\Theta&space;\left&space;(&space;n^{2}&space;\right&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\Theta&space;\left&space;(&space;n^{2}&space;\right&space;)" title="\Theta \left ( n^{2} \right )" /></a>的

然后按照常规套路整理，把所有关于i的扔到最后去得到

<a href="https://www.codecogs.com/eqnedit.php?latex=dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;-&space;F[i]&space;*&space;T[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]&space;\right&space;)\right&space;\}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;-&space;F[i]&space;*&space;T[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]&space;\right&space;)\right&space;\}" title="dp[i] = min\left \{ dp[j] - F[i] * T[j] + F[i] * \left ( s + T[i] \right )\right \}" /></a>

然后我们发现要使dp[i]最小，也就是要找出<a href="https://www.codecogs.com/eqnedit.php?latex=dp[j]&space;-&space;F[i]&space;*&space;T[j]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[j]&space;-&space;F[i]&space;*&space;T[j]" title="dp[j] - F[i] * T[j]" /></a>的j即可

然后问题就变成了对于二维坐标点集<a href="https://www.codecogs.com/eqnedit.php?latex=\left&space;(&space;dp[j],T[j]&space;\right&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\left&space;(&space;dp[j],T[j]&space;\right&space;)" title="\left ( dp[j],T[j] \right )" /></a>，给出斜率求最小的截距

~~这NM就开始想Kdtree，然后发现不会写动态插入kdtree~~

然后就发现了CDQ分治

其实刚开始自己并没有想到，因为实在不熟练CDQ，间接导致我调了一个世纪的程序

核心理念就是归并排序时，把j <= mid的点扔到左边，把j > mid的点扔到右边，这样对于每一个左边的点都可以更新右边的答案，而右边不可以更新左边

然后分治左边的答案，分治结束后左边维护一个下凸包

然后把右边部分按查询的斜率排序，这样可以在线性时间内更新答案

![1.jpg](https://i.loli.net/2018/12/22/5c1e1b69958a1.jpg)

''' c++
int n;
ll s;
struct node{
	ll x,k,y;
	int id;
}tsk[MAXN];
ll dp[MAXN];
bool cross(node a,node b,node c){
	long double k1;
	if (b.x == a.x)	k1 = b.y > a.y ? 1e20 : -1e20;
	else	k1 = (long double)(b.y - a.y) / (b.x - a.x);
	long double k2;
	if (c.x == a.x)	k2 = c.y > a.y ? 1e20 : -1e20;
	else k2 = (long double) (c.y - a.y) / (c.x - a.x);
	return k2 <= k1;
}
bool pd(node a,node b,ll K){
	ll x = b.x - a.x;ll y = b.y - a.y;
	if (x < 0)	return y > x * K;
	else 	return y < x * K;
}
node tp[MAXN];
node Q[MAXN];
void CDQ(int l,int r){
	if (l == r){
		tsk[l].y = dp[l];
		return;
	}
	int mid = (l + r) >> 1;
	int p1 = l,p2 = mid + 1;
	For(i,l,r + 1)	if (tsk[i].id <= mid)	tp[p1++] = tsk[i];	else tp[p2++] = tsk[i];
	For(i,l,r + 1)	tsk[i] = tp[i];
	CDQ(l,mid);
	int top = 0;
	For(i,l,mid + 1){
		while(top > 1 && cross(Q[top - 1],Q[top],tsk[i]))	top--;
		Q[++top] = tsk[i];
	}
	int j = 1;
	For(i,mid + 1,r + 1){
		while(j < top && pd(Q[j],Q[j + 1],tsk[i].k))	j++;
		dp[tsk[i].id] = min(dp[tsk[i].id],dp[Q[j].id] + tsk[i].k * (tsk[i].x - Q[j].x + s));
	}
	CDQ(mid + 1,r);
	p1 = l,p2 = mid + 1;
	For(i,l,r + 1){
		if (p1 <= mid && p2 <= r){
			if (tsk[p1].x < tsk[p2].x)	tp[i] = tsk[p1++];
			else 	tp[i] = tsk[p2++];
		}else
		if (p1 <= mid)	tp[i] = tsk[p1++];
		else
		tp[i] = tsk[p2++];
	}
	For(i,l,r + 1)	tsk[i] = tp[i];

}
int main(){
//	freopen("in.txt","r",stdin);
	scanf("%d%lld",&n,&s);
	for (int i = n;i >= 1;i--)	scanf("%lld%lld",&tsk[i].x,&tsk[i].k);	
	For(i,1,n + 1)	{
		tsk[i].x += tsk[i - 1].x;
		tsk[i].k += tsk[i - 1].k;
		dp[i] = tsk[i].k * (s + tsk[i].x);
		tsk[i].id = i;
	}
	dp[0] = 0;
	CDQ(1,n);
	printf("%lld\n",dp[n]);
	return 0;
} 
'''