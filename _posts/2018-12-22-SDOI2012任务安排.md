---
layout: post
title: 2018-12-22 [SDOI2012]任务安排

date: 2018-12-22
categories: blog
tags: [SDOI,2012]
description: BZOJ2726
---

---------------------

# Description

机器上有N个需要处理的任务，它们构成了一个序列。
这些任务被标号为1到N，因此序列的排列为1,2,3...N。
这N个任务被分成若干批，每批包含相邻的若干任务。
从时刻0开始，这些任务被分批加工，第i个任务单独完成所需的时间是Ti。
在每批任务开始前，机器需要启动时间S，而完成这批任务所需的时间是各个任务需要时间的总和。
注意，同一批任务将在同一时刻完成。每个任务的费用是它的完成时刻乘以一个费用系数Fi。
请确定一个分组方案，使得总费用最小。

# input

第一行两个整数，N,S。
接下来N行每行两个整数，Ti,Fi。
N <= 300000
 

# output

 一个整数，为所求的答案。

# Sample input

5 1

1 3

3 2

4 3

2 3

1 4

# Sample output

153

---------------------------------------------------------------------------------------------------------

# Answer

这个题非常有代表性了于是我自己想了很久

~~然后斜率优化被时间是负数卡了很久，佩服出题人可以把时间出成负数~~

首先把F和T倒过来读，然后求个前缀和

于是就写出了原始dp方程

dp[i]表示把后i个任务合理划分所需最少时间（倒过来了处理）

<a href="https://www.codecogs.com/eqnedit.php?latex=dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]-T[j]&space;\right&space;)\right&space;\}&space;\left&space;(&space;j&space;<&space;i&space;\right&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]-T[j]&space;\right&space;)\right&space;\}&space;\left&space;(&space;j&space;<&space;i&space;\right&space;)" title="dp[i] = min\left \{ dp[j] + F[i] * \left ( s + T[i]-T[j] \right )\right \} \left ( j < i \right )" /></a>

合情合理对吧。。。。然后目测是<a href="https://www.codecogs.com/eqnedit.php?latex=\Theta&space;\left&space;(&space;n^{2}&space;\right&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\Theta&space;\left&space;(&space;n^{2}&space;\right&space;)" title="\Theta \left ( n^{2} \right )" /></a>的

然后按照常规套路整理，把所有关于i的扔到最后去得到

<a href="https://www.codecogs.com/eqnedit.php?latex=dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;-&space;F[i]&space;*&space;T[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]&space;\right&space;)\right&space;\}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[i]&space;=&space;min\left&space;\{&space;dp[j]&space;-&space;F[i]&space;*&space;T[j]&space;&plus;&space;F[i]&space;*&space;\left&space;(&space;s&space;&plus;&space;T[i]&space;\right&space;)\right&space;\}" title="dp[i] = min\left \{ dp[j] - F[i] * T[j] + F[i] * \left ( s + T[i] \right )\right \}" /></a>

然后我们发现要使dp[i]最小，也就是要找出<a href="https://www.codecogs.com/eqnedit.php?latex=dp[j]&space;-&space;F[i]&space;*&space;T[j]" target="_blank"><img src="https://latex.codecogs.com/gif.latex?dp[j]&space;-&space;F[i]&space;*&space;T[j]" title="dp[j] - F[i] * T[j]" /></a>的j即可

然后问题就变成了对于二维坐标点集<a href="https://www.codecogs.com/eqnedit.php?latex=\left&space;(&space;dp[j],T[j]&space;\right&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\left&space;(&space;dp[j],T[j]&space;\right&space;)" title="\left ( dp[j],T[j] \right )" /></a>，给出斜率求最小的截距

~~这NM就开始想Kdtree，然后发现不会写动态插入kdtree~~

然后就发现了CDQ分治

其实刚开始自己并没有想到，因为实在不熟练CDQ，间接导致我调了一个世纪的程序

核心理念就是归并排序时，把j <= mid的点扔到左边，把j > mid的点扔到右边，这样对于每一个左边的点都可以更新右边的答案，而右边不可以更新左边

然后分治左边的答案，分治结束后左边维护一个下凸包

然后把右边部分按查询的斜率排序，这样可以在线性时间内更新答案

<img src="img\1.png" />