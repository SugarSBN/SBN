---
layout: post
title: 2019-3-3 BZOJ3065

date: 2019-3-3
categories: blog
tags: [BZOJ,3065]
description: 
---

---------------------

# Description
强制在线，支持修改，插入，不断查询区间第k小
n，q都在70000，插入不超过35000次

# sol

哇这个题看起来就充满了码农的意味

HINT里还写了个卡块状链表，自觉loglog

可本着两个log从来写不过去。。。。。~~自带大常数~~

于是我选择了分块

看到值的范围也只有70000

开sqrt(n)个块，然后deque记录下块内原数组，再BIT记录下就好了

每次查询时二分
复杂度理论上在<a href="https://www.codecogs.com/eqnedit.php?latex=\Theta&space;(q&space;\sqrt{n}log^{2}n)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\Theta&space;(q&space;\sqrt{n}log^{2}n)" title="\Theta (q \sqrt{n}log^{2}n)" /></a>
然而由于优秀的常数。。。。

``` c++


#define B 300
#define blk(o)	((o - 1) / B + 1)
#define num_of_block ((n - 1) / B + 1)
#define lb(o)	((o - 1) * B + 1)
#define rb(o)	(o * B)
int C[70001][B + 1];
inline int lowbit(int i){return i & -i;}
inline void add(int pos,int num,int bk){
	if (pos == 0){
		C[0][bk] += num;
		return;
	}
	for (int i = pos;i <= 70000;i += lowbit(i))	C[i][bk] += num;
}
inline int getsum(int pos,int bk){
	if (pos == 0)	return C[0][bk];
	int res = 0;
	for (int i = pos;i;i -= lowbit(i))	res += C[i][bk];
	return res + C[0][bk];
}
deque<int> D[B + 1];
int n,A[MAXN];
inline void push(int u){
	while(D[u].size() > B){
		add(D[u].back(),-1,u);
		add(D[u].back(),1,u + 1);
		D[u + 1].push_front(D[u].back());
		D[u].pop_back();
		u++;
	}
} 
inline void insert(int pos,int num){
	int bk = blk(pos);
	D[bk].insert(D[bk].begin() + pos - lb(bk),num);
	add(num,1,bk);
	push(bk);
	n++;
}
inline void modify(int pos,int num){
	int bk = blk(pos);
	int pre = D[bk][pos - lb(bk)];
	add(pre,-1,bk);
	add(num,1,bk);
	D[bk][pos - lb(bk)] = num;
}
inline int query(int l,int r,int num){
	int res = 0;
	if (blk(l) == blk(r)){
		For(i,0,D[blk(l)].size())	if (i + lb(blk(l)) >= l && i + lb(blk(r)) <= r && D[blk(l)][i] <= num)	res++;
		return res;
	}
	For(i,blk(l) + 1,blk(r))	res += getsum(num,i);
	For(i,0,D[blk(l)].size())	if (i + lb(blk(l)) >= l && D[blk(l)][i] <= num)	res++;
	For(i,0,D[blk(r)].size())	if (i + lb(blk(r)) <= r && D[blk(r)][i] <= num)	res++;
	return res;
}
inline int k_th(int l,int r,int k){
	int lb = 0,rb = 70000;
	while(lb < rb){
		int mid = (lb + rb) >> 1;
		if (query(l,r,mid) < k)	lb = mid + 1;
		else rb = mid;
	}
	return rb;
}
int q;

void input();
void solve();
void print(){
	For(i,1,num_of_block + 1)	For(j,0,D[i].size())	cout<<D[i][j]<<" ";cout<<endl;
}

int lstans = 0;
int main(){
//	freopen("in.txt","r",stdin);
	input();
	solve();
	return 0;
}
void solve(){
	scanf("%d",&q);lstans = 0;
	char opt[2];
	int l,r,val,k,pos;
	while(q--){
		scanf("%s",opt);
		if (opt[0] == 'Q'){
			scanf("%d%d%d",&l,&r,&k);l ^= lstans;r ^= lstans;k ^= lstans;
			lstans = k_th(l,r,k);
			printf("%d\n",lstans);
		}
		if (opt[0] == 'M'){
			scanf("%d%d",&pos,&val);pos ^= lstans;val ^= lstans;
			modify(pos,val);
		}
		if (opt[0] == 'I'){
			scanf("%d%d",&pos,&val);pos ^= lstans;val ^= lstans;
			insert(pos,val);
		}
	}	
}
void input(){
	scanf("%d",&n);
	For(i,1,n + 1)	scanf("%d",A + i);
	For(i,1,n + 1){
		D[blk(i)].push_back(A[i]);
		add(A[i],1,blk(i));
	}
}
```