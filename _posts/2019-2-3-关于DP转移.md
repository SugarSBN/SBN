---
layout: post
title: 2019-2-3 关于DP转移

date: 2019-2-3
categories: blog
tags: [JSOI,2007]
description: 
---

---------------------


好久没有更新

然后今天终于忍不住了

调一个题叫什么[JSOI2007]文本生成器

本来这个题很好做，DP很好想，然后却发现DP转移不能使用SPFA式转移否则会莫名WA

然后困扰了我好久好久

然后刚刚才发现问题

首先我们看两种转移

# 正确：

```c++
For(i,0,m)	For(j,0,siz + 1)if (dp[i][j])	
	For(k,0,26){
		if (!AC[AC[j].ch[k]].val){
			dp[i + 1][AC[j].ch[k]] = (dp[i + 1][AC[j].ch[k]] + dp[i][j]) % MOD;
		}
	}
```
# 错误：
```c++
queue<pair<int,pii> > Q;
Q.push(mp(1,mp(0,0)));
while(!Q.empty()){
	pair<int,pii> u = Q.front();Q.pop();
	if (u.fi != dp[u.se.fi][u.se.se] || u.se.fi == m)	continue;
	For(i,0,26){
		int v = AC[u.se.se].ch[i];
		if (!AC[v].val){
			dp[u.se.fi + 1][v] = (dp[u.se.fi + 1][v] + dp[u.se.fi][u.se.se]) % MOD;
			Q.push(mp(dp[u.se.fi + 1][v],mp(u.se.fi + 1,v)));
		}
	}
}
```

虽然我写的很丑。。。。。。。但是将就着看下

然后问题出在哪里。。。。。。看起来都是AC自动机上往子节点的转移

然鹅问题出在

```c++
if (u.fi != dp[u.se.fi][u.se.se] || u.se.fi == m)	continue;
```

实际上u.se.fi == m这个判断没有错误

然鹅错在前面这个不等关系

加这个判断的目的在于保证这个状态往后转移时他是最后一次入队，也就是这个状态已经没有前驱

然而这个判断有问题的

并且这个题的MOD丧心病狂只有10007

所以很有可能这个状态还没转移完和转移完后的值关于10007同余。。。。导致这个状态往后转移了多次

经过实验把MOD改成19260817冲突的概率就近乎没有了(/滑稽)

这真是一个极为不易发现而且致命的错误哇