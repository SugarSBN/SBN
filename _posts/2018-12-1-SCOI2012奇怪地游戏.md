---
layout: post
title: 2018-12-1 [SCOI2012]奇怪的游戏

date: 2018-12-1
categories: blog
tags: [SCOI,2012]
description: BZOJ2756
---

---------------------

# Description

Blinker最近喜欢上一个奇怪的游戏。 
这个游戏在一个 N×M 的棋盘上玩，每个格子有一个数。每次
Blinker会选择两个相邻的格子，并使这两个数都加上1。 
现在
Blinker想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出−1。 

# input

输入的第一行是一个整数T，表示输入数据有T轮游戏组成。 
每轮游戏的第一行有两个整数N和M， 分别代表棋盘的行数和列数。 
接下来有N行，每行 M个数。 

# output

 对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出-1。 

# Sample input

2 

2 2 

1 2 

2 3 

3 3 

1 2 3 

2 3 4 

4 3 2 

# Sample output

2 

-1 

---------------------------------------------------------------------------------------------------------

# Answer

先说个好玩的事：下午上课，WJ：有许多算法以人名命名。譬如Tarjan。而SPFA则是四个人名缩写

~~那这四个人一定是Shortest,Path,Fast,Algorithm了~~

再说题目

不难发现是骨牌覆盖问题，肯定可以想到染色

然后40的数据排除了状压/枚举

只好想多项式的办法

然后不难发现肯定堆得越低越好

于是可以二分

然后大致想法出来了：

cnt1/cnt2 分别表示 白色/黑色块的个数

sum1/sum2分别表示白色/黑色块上的数字和

每次操作就是把一个白色和一个黑色同时+1

如果最后结果数字是x

cnt1 * x - sum1 = cnt2 * x - sum2

x = (sum1 - sum2) / (cnt1 - cnt2)

然后cnt1 != cnt2时检查一下x能不能堆成就好了

如果等于的话就二分一个x求最小好了(因为对于一个x满足要求则大于x的也肯定满足)

~~然后我没想出来怎么check~~

~~然后看了黄学长博客~~

可以用网络流，源点向每个黑点连一条边，flow是x - w[这个点]

每个黑点向相邻白点连一条边，flow是INF

每个白点向汇点连一条边，flow是x - w[这个点]

然后如果存在一种满流方案则x合法 (实际上就是在匹配)

~~然后我不加当前弧优化挂了一半~~

~~然后加了还是挂，才发现自己写的假的当前弧优化~~

# Code:

``` c++

struct node{
	int x,y,nxt;
	ll flow;
	node(){}
	node(int nx,int ny,int nnxt,ll nflow){
		x = nx;y = ny;nxt = nnxt;flow = nflow;
	}
}E[MAXN << 1];
int head[MAXN],cnt;
inline void cleargraph(){
	memset(head,0,sizeof(head));
	For(i,2,cnt + 1)	E[i].nxt = 0;
	cnt = 1;
}
inline void link(int x,int y,ll len){
	E[++cnt] = node(x,y,head[x],len);
	head[x] = cnt;
	E[++cnt] = node(y,x,head[y],0);
	head[y] = cnt;
} 
int n,m,dis[1602],cur[1602];
bool bfs(){
	For(i,0,n * m + 2)	dis[i] = -1;
	queue<int> Q;
	Q.push(0);
	dis[0] = 0;
	while(!Q.empty()){
		int u = Q.front();Q.pop();
		for (int i = head[u];i;i = E[i].nxt)	if (dis[E[i].y] == -1 && E[i].flow > 0){
			dis[E[i].y] = dis[u] + 1;
			Q.push(E[i].y);
		}
	}
	return dis[n * m + 1] >= 0;
}
ll Dinic(int u,ll now){
	if (u == n * m + 1)	return now;
	ll res = 0;
	for (int i = cur[u];i;i = E[i].nxt)	if (dis[E[i].y] == dis[u] + 1){	
		ll res1 = Dinic(E[i].y,min(now - res,E[i].flow));
		E[i].flow -= res1;
		E[i ^ 1].flow += res1;
		if (E[i].flow)	cur[u] = i;
		res += res1;
		if(res == now)	return now; 
	}
	if (!res)	dis[u] = -1;
	return res;
}
ll MaxFlow(){
	ll ans = 0,tans = 0;
	while(bfs())	{
		For(i,0,n * m + 2)	cur[i] = head[i];
		ans += Dinic(0,INF);
	}
	return ans;
}
ll w[41][41],cnt0,cnt1,sum0,sum1,mx;
bool check(ll ANS){
	cleargraph();
	ll tot = 0;
	For(i,0,n)	For(j,0,m)	if (i % 2 == j % 2){
		link(0,i * m + j + 1,ANS - w[i][j]);
		if (j < m - 1)	link(i * m + j + 1,i * m + j + 2,INF);
		if (i < n - 1)	link(i * m + j + 1,i * m + m + j + 1,INF);
		if (j > 0)	link(i * m + j + 1,i * m + j,INF);
		if (i > 0)	link(i * m + j + 1,i * m + j + 1 - m,INF);
		tot += ANS - w[i][j];
	}else	link(i * m + j + 1,n * m + 1,ANS - w[i][j]);
	return MaxFlow() == tot;
}
int T;
int main(){
//	freopen("in.txt","r",stdin);
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		mx = 0;
		For(i,0,n)	For(j,0,m)	{
			scanf("%lld",w[i] + j);
			mx = max(mx,w[i][j]);
		}
		cnt0 = cnt1 = 0;
		sum0 = sum1 = 0;
		For(i,0,n)	For(j,0,m)	if (i % 2 == j % 2){
			cnt0++;
			sum0 += w[i][j];
		}else{
			cnt1++;
			sum1 += w[i][j];
		}
		if (cnt0 != cnt1){
			ll ans = (sum0 - sum1) / (cnt0 - cnt1);
			if (ans >= mx && check(ans))
				printf("%lld\n",ans * cnt1 - sum1);
			else	puts("-1");
		}else{
			if (sum0 != sum1){
				puts("-1");
				continue;
			}
			ll lb = mx,rb = INF;
			while(lb < rb - 1){
				ll mid = (lb + rb) >> 1;
				if (check(mid))	rb = mid;
				else lb = mid + 1;
			}
			if (check(lb))	rb = lb;
			printf("%lld\n",rb * cnt1 - sum1);
		}
	}
	return 0;
} 

```